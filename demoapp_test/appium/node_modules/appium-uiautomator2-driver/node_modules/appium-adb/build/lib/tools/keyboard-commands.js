"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _logger = _interopRequireDefault(require("../logger.js"));

var _asyncbox = require("asyncbox");

const KEYCODE_ESC = 111;
const KEYCODE_BACK = 4;
const keyboardCommands = {};

keyboardCommands.hideKeyboard = async function hideKeyboard(timeoutMs = 1000) {
  let {
    isKeyboardShown,
    canCloseKeyboard
  } = await this.isSoftKeyboardPresent();

  if (!isKeyboardShown) {
    _logger.default.info('Keyboard has no UI; no closing necessary');

    return false;
  }

  for (const keyCode of [KEYCODE_ESC, KEYCODE_BACK]) {
    if (canCloseKeyboard) {
      await this.keyevent(keyCode);
    }

    try {
      return await (0, _asyncbox.waitForCondition)(async () => {
        ({
          isKeyboardShown
        } = await this.isSoftKeyboardPresent());
        return !isKeyboardShown;
      }, {
        waitMs: timeoutMs,
        intervalMs: 500
      });
    } catch (ign) {}
  }

  throw new Error(`The software keyboard cannot be hidden`);
};

keyboardCommands.isSoftKeyboardPresent = async function isSoftKeyboardPresent() {
  try {
    const stdout = await this.shell(['dumpsys', 'input_method']);
    const inputShownMatch = /mInputShown=(\w+)/.exec(stdout);
    const inputViewShownMatch = /mIsInputViewShown=(\w+)/.exec(stdout);
    return {
      isKeyboardShown: !!(inputShownMatch && inputShownMatch[1] === 'true'),
      canCloseKeyboard: !!(inputViewShownMatch && inputViewShownMatch[1] === 'true')
    };
  } catch (e) {
    throw new Error(`Error finding softkeyboard. Original error: ${e.message}`);
  }
};

var _default = keyboardCommands;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJLRVlDT0RFX0VTQyIsIktFWUNPREVfQkFDSyIsImtleWJvYXJkQ29tbWFuZHMiLCJoaWRlS2V5Ym9hcmQiLCJ0aW1lb3V0TXMiLCJpc0tleWJvYXJkU2hvd24iLCJjYW5DbG9zZUtleWJvYXJkIiwiaXNTb2Z0S2V5Ym9hcmRQcmVzZW50IiwibG9nIiwiaW5mbyIsImtleUNvZGUiLCJrZXlldmVudCIsIndhaXRGb3JDb25kaXRpb24iLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiaWduIiwiRXJyb3IiLCJzdGRvdXQiLCJzaGVsbCIsImlucHV0U2hvd25NYXRjaCIsImV4ZWMiLCJpbnB1dFZpZXdTaG93bk1hdGNoIiwiZSIsIm1lc3NhZ2UiXSwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvdG9vbHMva2V5Ym9hcmQtY29tbWFuZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcblxuY29uc3QgS0VZQ09ERV9FU0MgPSAxMTE7XG5jb25zdCBLRVlDT0RFX0JBQ0sgPSA0O1xuXG5jb25zdCBrZXlib2FyZENvbW1hbmRzID0ge307XG5cbi8qKlxuICogSGlkZXMgc29mdHdhcmUga2V5Ym9hcmQgaWYgaXQgaXMgdmlzaWJsZS5cbiAqIE5vb3AgaWYgdGhlIGtleWJvYXJkIGlzIGFscmVhZHkgaGlkZGVuLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzEwMDBdIEZvciBob3cgbG9uZyB0byB3YWl0IChpbiBtaWxsaXNlY29uZHMpXG4gKiB1bnRpbCB0aGUga2V5Ym9hcmQgaXMgYWN0dWFsbHkgaGlkZGVuLlxuICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgdGhlIGtleWJvYXJkIHdhcyBhbHJlYWR5IGhpZGRlblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuLlxuICovXG5rZXlib2FyZENvbW1hbmRzLmhpZGVLZXlib2FyZCA9IGFzeW5jIGZ1bmN0aW9uIGhpZGVLZXlib2FyZCAodGltZW91dE1zID0gMTAwMCkge1xuICBsZXQge2lzS2V5Ym9hcmRTaG93biwgY2FuQ2xvc2VLZXlib2FyZH0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpO1xuICBpZiAoIWlzS2V5Ym9hcmRTaG93bikge1xuICAgIGxvZy5pbmZvKCdLZXlib2FyZCBoYXMgbm8gVUk7IG5vIGNsb3NpbmcgbmVjZXNzYXJ5Jyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRyeSBFU0MgdGhlbiBCQUNLIGlmIHRoZSBmaXJzdCBvbmUgZmFpbHNcbiAgZm9yIChjb25zdCBrZXlDb2RlIG9mIFtLRVlDT0RFX0VTQywgS0VZQ09ERV9CQUNLXSkge1xuICAgIGlmIChjYW5DbG9zZUtleWJvYXJkKSB7XG4gICAgICBhd2FpdCB0aGlzLmtleWV2ZW50KGtleUNvZGUpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAoe2lzS2V5Ym9hcmRTaG93bn0gPSBhd2FpdCB0aGlzLmlzU29mdEtleWJvYXJkUHJlc2VudCgpKTtcbiAgICAgICAgcmV0dXJuICFpc0tleWJvYXJkU2hvd247XG4gICAgICB9LCB7d2FpdE1zOiB0aW1lb3V0TXMsIGludGVydmFsTXM6IDUwMH0pO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzb2Z0d2FyZSBrZXlib2FyZCBjYW5ub3QgYmUgaGlkZGVuYCk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEtleWJvYXJkU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNLZXlib2FyZFNob3duIC0gV2hldGhlciBzb2Z0IGtleWJvYXJkIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5DbG9zZUtleWJvYXJkIC0gV2hldGhlciB0aGUga2V5Ym9hcmQgY2FuIGJlIGNsb3NlZC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBzdGF0ZSBvZiB0aGUgc29mdHdhcmUga2V5Ym9hcmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0tleWJvYXJkU3RhdGV9IFRoZSBrZXlib2FyZCBzdGF0ZS5cbiAqL1xua2V5Ym9hcmRDb21tYW5kcy5pc1NvZnRLZXlib2FyZFByZXNlbnQgPSBhc3luYyBmdW5jdGlvbiBpc1NvZnRLZXlib2FyZFByZXNlbnQgKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydkdW1wc3lzJywgJ2lucHV0X21ldGhvZCddKTtcbiAgICBjb25zdCBpbnB1dFNob3duTWF0Y2ggPSAvbUlucHV0U2hvd249KFxcdyspLy5leGVjKHN0ZG91dCk7XG4gICAgY29uc3QgaW5wdXRWaWV3U2hvd25NYXRjaCA9IC9tSXNJbnB1dFZpZXdTaG93bj0oXFx3KykvLmV4ZWMoc3Rkb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNLZXlib2FyZFNob3duOiAhIShpbnB1dFNob3duTWF0Y2ggJiYgaW5wdXRTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgICAgY2FuQ2xvc2VLZXlib2FyZDogISEoaW5wdXRWaWV3U2hvd25NYXRjaCAmJiBpbnB1dFZpZXdTaG93bk1hdGNoWzFdID09PSAndHJ1ZScpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZpbmRpbmcgc29mdGtleWJvYXJkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGtleWJvYXJkQ29tbWFuZHM7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUEsTUFBTUEsV0FBVyxHQUFHLEdBQXBCO0FBQ0EsTUFBTUMsWUFBWSxHQUFHLENBQXJCO0FBRUEsTUFBTUMsZ0JBQWdCLEdBQUcsRUFBekI7O0FBV0FBLGdCQUFnQixDQUFDQyxZQUFqQixHQUFnQyxlQUFlQSxZQUFmLENBQTZCQyxTQUFTLEdBQUcsSUFBekMsRUFBK0M7RUFDN0UsSUFBSTtJQUFDQyxlQUFEO0lBQWtCQztFQUFsQixJQUFzQyxNQUFNLEtBQUtDLHFCQUFMLEVBQWhEOztFQUNBLElBQUksQ0FBQ0YsZUFBTCxFQUFzQjtJQUNwQkcsZUFBQSxDQUFJQyxJQUFKLENBQVMsMENBQVQ7O0lBQ0EsT0FBTyxLQUFQO0VBQ0Q7O0VBRUQsS0FBSyxNQUFNQyxPQUFYLElBQXNCLENBQUNWLFdBQUQsRUFBY0MsWUFBZCxDQUF0QixFQUFtRDtJQUNqRCxJQUFJSyxnQkFBSixFQUFzQjtNQUNwQixNQUFNLEtBQUtLLFFBQUwsQ0FBY0QsT0FBZCxDQUFOO0lBQ0Q7O0lBQ0QsSUFBSTtNQUNGLE9BQU8sTUFBTSxJQUFBRSwwQkFBQSxFQUFpQixZQUFZO1FBQ3hDLENBQUM7VUFBQ1A7UUFBRCxJQUFvQixNQUFNLEtBQUtFLHFCQUFMLEVBQTNCO1FBQ0EsT0FBTyxDQUFDRixlQUFSO01BQ0QsQ0FIWSxFQUdWO1FBQUNRLE1BQU0sRUFBRVQsU0FBVDtRQUFvQlUsVUFBVSxFQUFFO01BQWhDLENBSFUsQ0FBYjtJQUlELENBTEQsQ0FLRSxPQUFPQyxHQUFQLEVBQVksQ0FBRTtFQUNqQjs7RUFDRCxNQUFNLElBQUlDLEtBQUosQ0FBVyx3Q0FBWCxDQUFOO0FBQ0QsQ0FuQkQ7O0FBZ0NBZCxnQkFBZ0IsQ0FBQ0sscUJBQWpCLEdBQXlDLGVBQWVBLHFCQUFmLEdBQXdDO0VBQy9FLElBQUk7SUFDRixNQUFNVSxNQUFNLEdBQUcsTUFBTSxLQUFLQyxLQUFMLENBQVcsQ0FBQyxTQUFELEVBQVksY0FBWixDQUFYLENBQXJCO0lBQ0EsTUFBTUMsZUFBZSxHQUFHLG9CQUFvQkMsSUFBcEIsQ0FBeUJILE1BQXpCLENBQXhCO0lBQ0EsTUFBTUksbUJBQW1CLEdBQUcsMEJBQTBCRCxJQUExQixDQUErQkgsTUFBL0IsQ0FBNUI7SUFDQSxPQUFPO01BQ0xaLGVBQWUsRUFBRSxDQUFDLEVBQUVjLGVBQWUsSUFBSUEsZUFBZSxDQUFDLENBQUQsQ0FBZixLQUF1QixNQUE1QyxDQURiO01BRUxiLGdCQUFnQixFQUFFLENBQUMsRUFBRWUsbUJBQW1CLElBQUlBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkIsS0FBMkIsTUFBcEQ7SUFGZCxDQUFQO0VBSUQsQ0FSRCxDQVFFLE9BQU9DLENBQVAsRUFBVTtJQUNWLE1BQU0sSUFBSU4sS0FBSixDQUFXLCtDQUE4Q00sQ0FBQyxDQUFDQyxPQUFRLEVBQW5FLENBQU47RUFDRDtBQUNGLENBWkQ7O2VBY2VyQixnQiJ9