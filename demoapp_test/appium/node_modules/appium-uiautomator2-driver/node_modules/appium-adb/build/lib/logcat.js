"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _support = require("@appium/support");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _events = _interopRequireDefault(require("events"));

var _teen_process = require("teen_process");

const {
  EventEmitter
} = _events.default;

const log = _support.logger.getLogger('Logcat');

const MAX_BUFFER_SIZE = 10000;
const LOGCAT_PROC_STARTUP_TIMEOUT = 10000;
const SUPPORTED_FORMATS = ['brief', 'process', 'tag', 'thread', 'raw', 'time', 'threadtime', 'long'];
const SUPPORTED_PRIORITIES = ['v', 'd', 'i', 'w', 'e', 'f', 's'];
const DEFAULT_PRIORITY = 'v';
const DEFAULT_TAG = '*';
const DEFAULT_FORMAT = 'threadtime';

function requireFormat(format) {
  if (!SUPPORTED_FORMATS.includes(format)) {
    log.info(`The format value '${format}' is unknown. Supported values are: ${SUPPORTED_FORMATS}`);
    log.info(`Defaulting to '${DEFAULT_FORMAT}'`);
    return DEFAULT_FORMAT;
  }

  return format;
}

function requireSpec(spec) {
  const [tag, priority] = spec.split(':');
  let resultTag = tag;

  if (!resultTag) {
    log.info(`The tag value in spec '${spec}' cannot be empty`);
    log.info(`Defaulting to '${DEFAULT_TAG}'`);
    resultTag = DEFAULT_TAG;
  }

  if (!priority) {
    log.info(`The priority value in spec '${spec}' is empty. Defaulting to Verbose (${DEFAULT_PRIORITY})`);
    return `${resultTag}:${DEFAULT_PRIORITY}`;
  }

  if (!SUPPORTED_PRIORITIES.some(p => _lodash.default.toLower(priority) === _lodash.default.toLower(p))) {
    log.info(`The priority value in spec '${spec}' is unknown. Supported values are: ${SUPPORTED_PRIORITIES}`);
    log.info(`Defaulting to Verbose (${DEFAULT_PRIORITY})`);
    return `${resultTag}:${DEFAULT_PRIORITY}`;
  }

  return spec;
}

function formatFilterSpecs(filterSpecs) {
  if (!_lodash.default.isArray(filterSpecs)) {
    filterSpecs = [filterSpecs];
  }

  return filterSpecs.filter(spec => spec && _lodash.default.isString(spec) && !spec.startsWith('-')).map(spec => spec.includes(':') ? requireSpec(spec) : spec);
}

class Logcat extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.adb = opts.adb;
    this.clearLogs = opts.clearDeviceLogsOnStart || false;
    this.debug = opts.debug;
    this.debugTrace = opts.debugTrace;
    this.maxBufferSize = opts.maxBufferSize || MAX_BUFFER_SIZE;
    this.logs = [];
    this.logIdxSinceLastRequest = 0;
  }

  async startCapture(opts = {}) {
    let started = false;
    return await new _bluebird.default(async (_resolve, _reject) => {
      const resolve = function (...args) {
        started = true;

        _resolve(...args);
      };

      const reject = function (...args) {
        started = true;

        _reject(...args);
      };

      if (this.clearLogs) {
        await this.clear();
      }

      const {
        format = DEFAULT_FORMAT,
        filterSpecs = []
      } = opts;
      const cmd = [...this.adb.defaultArgs, 'logcat', '-v', requireFormat(format), ...formatFilterSpecs(filterSpecs)];
      log.debug(`Starting logs capture with command: ${_support.util.quote([this.adb.path, ...cmd])}`);
      this.proc = new _teen_process.SubProcess(this.adb.path, cmd);
      this.proc.on('exit', (code, signal) => {
        log.error(`Logcat terminated with code ${code}, signal ${signal}`);
        this.proc = null;

        if (!started) {
          log.warn('Logcat not started. Continuing');
          resolve();
        }
      });
      this.proc.on('lines-stderr', lines => {
        for (let line of lines) {
          if (/execvp\(\)/.test(line)) {
            log.error('Logcat process failed to start');
            reject(new Error(`Logcat process failed to start. stderr: ${line}`));
          }

          this.outputHandler(_lodash.default.trim(line), 'STDERR: ');
        }

        resolve();
      });
      this.proc.on('lines-stdout', lines => {
        resolve();

        for (let line of lines) {
          this.outputHandler(_lodash.default.trim(line));
        }
      });
      await this.proc.start(0);
      setTimeout(resolve, LOGCAT_PROC_STARTUP_TIMEOUT);
    });
  }

  outputHandler(output, prefix = '') {
    if (!output) {
      return;
    }

    if (this.logs.length >= this.maxBufferSize) {
      this.logs.shift();

      if (this.logIdxSinceLastRequest > 0) {
        --this.logIdxSinceLastRequest;
      }
    }

    const outputObj = {
      timestamp: Date.now(),
      level: 'ALL',
      message: output
    };
    this.logs.push(outputObj);
    this.emit('output', outputObj);
    const isTrace = /W\/Trace/.test(output);

    if (this.debug && (!isTrace || this.debugTrace)) {
      log.debug(prefix + output);
    }
  }

  async stopCapture() {
    log.debug('Stopping logcat capture');

    if (!this.proc || !this.proc.isRunning) {
      log.debug('Logcat already stopped');
      this.proc = null;
      return;
    }

    this.proc.removeAllListeners('exit');
    await this.proc.stop();
    this.proc = null;
  }

  getLogs() {
    if (this.logIdxSinceLastRequest < this.logs.length) {
      const result = this.logs.slice(this.logIdxSinceLastRequest);
      this.logIdxSinceLastRequest = this.logs.length;
      return result;
    }

    return [];
  }

  getAllLogs() {
    return this.logs;
  }

  async clear() {
    log.debug('Clearing logcat logs from device');

    try {
      const args = [...this.adb.defaultArgs, 'logcat', '-c'];
      await (0, _teen_process.exec)(this.adb.path, args);
    } catch (err) {
      log.warn(`Failed to clear logcat logs: ${err.stderr || err.message}`);
    }
  }

}

var _default = Logcat;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJldmVudHMiLCJsb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJNQVhfQlVGRkVSX1NJWkUiLCJMT0dDQVRfUFJPQ19TVEFSVFVQX1RJTUVPVVQiLCJTVVBQT1JURURfRk9STUFUUyIsIlNVUFBPUlRFRF9QUklPUklUSUVTIiwiREVGQVVMVF9QUklPUklUWSIsIkRFRkFVTFRfVEFHIiwiREVGQVVMVF9GT1JNQVQiLCJyZXF1aXJlRm9ybWF0IiwiZm9ybWF0IiwiaW5jbHVkZXMiLCJpbmZvIiwicmVxdWlyZVNwZWMiLCJzcGVjIiwidGFnIiwicHJpb3JpdHkiLCJzcGxpdCIsInJlc3VsdFRhZyIsInNvbWUiLCJwIiwiXyIsInRvTG93ZXIiLCJmb3JtYXRGaWx0ZXJTcGVjcyIsImZpbHRlclNwZWNzIiwiaXNBcnJheSIsImZpbHRlciIsImlzU3RyaW5nIiwic3RhcnRzV2l0aCIsIm1hcCIsIkxvZ2NhdCIsImNvbnN0cnVjdG9yIiwib3B0cyIsImFkYiIsImNsZWFyTG9ncyIsImNsZWFyRGV2aWNlTG9nc09uU3RhcnQiLCJkZWJ1ZyIsImRlYnVnVHJhY2UiLCJtYXhCdWZmZXJTaXplIiwibG9ncyIsImxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QiLCJzdGFydENhcHR1cmUiLCJzdGFydGVkIiwiQiIsIl9yZXNvbHZlIiwiX3JlamVjdCIsInJlc29sdmUiLCJhcmdzIiwicmVqZWN0IiwiY2xlYXIiLCJjbWQiLCJkZWZhdWx0QXJncyIsInV0aWwiLCJxdW90ZSIsInBhdGgiLCJwcm9jIiwiU3ViUHJvY2VzcyIsIm9uIiwiY29kZSIsInNpZ25hbCIsImVycm9yIiwid2FybiIsImxpbmVzIiwibGluZSIsInRlc3QiLCJFcnJvciIsIm91dHB1dEhhbmRsZXIiLCJ0cmltIiwic3RhcnQiLCJzZXRUaW1lb3V0Iiwib3V0cHV0IiwicHJlZml4IiwibGVuZ3RoIiwic2hpZnQiLCJvdXRwdXRPYmoiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwibGV2ZWwiLCJtZXNzYWdlIiwicHVzaCIsImVtaXQiLCJpc1RyYWNlIiwic3RvcENhcHR1cmUiLCJpc1J1bm5pbmciLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJzdG9wIiwiZ2V0TG9ncyIsInJlc3VsdCIsInNsaWNlIiwiZ2V0QWxsTG9ncyIsImV4ZWMiLCJlcnIiLCJzdGRlcnIiXSwic291cmNlcyI6WyIuLi8uLi9saWIvbG9nY2F0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBsb2dnZXIsIHV0aWwgfSBmcm9tICdAYXBwaXVtL3N1cHBvcnQnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IGV2ZW50cztcbmltcG9ydCB7IFN1YlByb2Nlc3MsIGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuXG5jb25zdCBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKCdMb2djYXQnKTtcbmNvbnN0IE1BWF9CVUZGRVJfU0laRSA9IDEwMDAwO1xuY29uc3QgTE9HQ0FUX1BST0NfU1RBUlRVUF9USU1FT1VUID0gMTAwMDA7XG5jb25zdCBTVVBQT1JURURfRk9STUFUUyA9IFsnYnJpZWYnLCAncHJvY2VzcycsICd0YWcnLCAndGhyZWFkJywgJ3JhdycsICd0aW1lJywgJ3RocmVhZHRpbWUnLCAnbG9uZyddO1xuY29uc3QgU1VQUE9SVEVEX1BSSU9SSVRJRVMgPSBbJ3YnLCAnZCcsICdpJywgJ3cnLCAnZScsICdmJywgJ3MnXTtcbmNvbnN0IERFRkFVTFRfUFJJT1JJVFkgPSAndic7XG5jb25zdCBERUZBVUxUX1RBRyA9ICcqJztcbmNvbnN0IERFRkFVTFRfRk9STUFUID0gJ3RocmVhZHRpbWUnO1xuXG5mdW5jdGlvbiByZXF1aXJlRm9ybWF0IChmb3JtYXQpIHtcbiAgaWYgKCFTVVBQT1JURURfRk9STUFUUy5pbmNsdWRlcyhmb3JtYXQpKSB7XG4gICAgbG9nLmluZm8oYFRoZSBmb3JtYXQgdmFsdWUgJyR7Zm9ybWF0fScgaXMgdW5rbm93bi4gU3VwcG9ydGVkIHZhbHVlcyBhcmU6ICR7U1VQUE9SVEVEX0ZPUk1BVFN9YCk7XG4gICAgbG9nLmluZm8oYERlZmF1bHRpbmcgdG8gJyR7REVGQVVMVF9GT1JNQVR9J2ApO1xuICAgIHJldHVybiBERUZBVUxUX0ZPUk1BVDtcbiAgfVxuICByZXR1cm4gZm9ybWF0O1xufVxuXG5mdW5jdGlvbiByZXF1aXJlU3BlYyAoc3BlYykge1xuICBjb25zdCBbdGFnLCBwcmlvcml0eV0gPSBzcGVjLnNwbGl0KCc6Jyk7XG4gIGxldCByZXN1bHRUYWcgPSB0YWc7XG4gIGlmICghcmVzdWx0VGFnKSB7XG4gICAgbG9nLmluZm8oYFRoZSB0YWcgdmFsdWUgaW4gc3BlYyAnJHtzcGVjfScgY2Fubm90IGJlIGVtcHR5YCk7XG4gICAgbG9nLmluZm8oYERlZmF1bHRpbmcgdG8gJyR7REVGQVVMVF9UQUd9J2ApO1xuICAgIHJlc3VsdFRhZyA9IERFRkFVTFRfVEFHO1xuICB9XG4gIGlmICghcHJpb3JpdHkpIHtcbiAgICBsb2cuaW5mbyhgVGhlIHByaW9yaXR5IHZhbHVlIGluIHNwZWMgJyR7c3BlY30nIGlzIGVtcHR5LiBEZWZhdWx0aW5nIHRvIFZlcmJvc2UgKCR7REVGQVVMVF9QUklPUklUWX0pYCk7XG4gICAgcmV0dXJuIGAke3Jlc3VsdFRhZ306JHtERUZBVUxUX1BSSU9SSVRZfWA7XG4gIH1cbiAgaWYgKCFTVVBQT1JURURfUFJJT1JJVElFUy5zb21lKChwKSA9PiBfLnRvTG93ZXIocHJpb3JpdHkpID09PSBfLnRvTG93ZXIocCkpKSB7XG4gICAgbG9nLmluZm8oYFRoZSBwcmlvcml0eSB2YWx1ZSBpbiBzcGVjICcke3NwZWN9JyBpcyB1bmtub3duLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZTogJHtTVVBQT1JURURfUFJJT1JJVElFU31gKTtcbiAgICBsb2cuaW5mbyhgRGVmYXVsdGluZyB0byBWZXJib3NlICgke0RFRkFVTFRfUFJJT1JJVFl9KWApO1xuICAgIHJldHVybiBgJHtyZXN1bHRUYWd9OiR7REVGQVVMVF9QUklPUklUWX1gO1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRGaWx0ZXJTcGVjcyAoZmlsdGVyU3BlY3MpIHtcbiAgaWYgKCFfLmlzQXJyYXkoZmlsdGVyU3BlY3MpKSB7XG4gICAgZmlsdGVyU3BlY3MgPSBbZmlsdGVyU3BlY3NdO1xuICB9XG4gIHJldHVybiBmaWx0ZXJTcGVjc1xuICAgIC5maWx0ZXIoKHNwZWMpID0+IHNwZWMgJiYgXy5pc1N0cmluZyhzcGVjKSAmJiAhc3BlYy5zdGFydHNXaXRoKCctJykpXG4gICAgLm1hcCgoc3BlYykgPT4gc3BlYy5pbmNsdWRlcygnOicpID8gcmVxdWlyZVNwZWMoc3BlYykgOiBzcGVjKTtcbn1cblxuXG5jbGFzcyBMb2djYXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFkYiA9IG9wdHMuYWRiO1xuICAgIHRoaXMuY2xlYXJMb2dzID0gb3B0cy5jbGVhckRldmljZUxvZ3NPblN0YXJ0IHx8IGZhbHNlO1xuICAgIHRoaXMuZGVidWcgPSBvcHRzLmRlYnVnO1xuICAgIHRoaXMuZGVidWdUcmFjZSA9IG9wdHMuZGVidWdUcmFjZTtcbiAgICB0aGlzLm1heEJ1ZmZlclNpemUgPSBvcHRzLm1heEJ1ZmZlclNpemUgfHwgTUFYX0JVRkZFUl9TSVpFO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA9IDA7XG4gIH1cblxuICBhc3luYyBzdGFydENhcHR1cmUgKG9wdHMgPSB7fSkge1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBCKGFzeW5jIChfcmVzb2x2ZSwgX3JlamVjdCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcGFyYW0tbmFtZXNcbiAgICAgIGNvbnN0IHJlc29sdmUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgX3Jlc29sdmUoLi4uYXJncyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVqZWN0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIF9yZWplY3QoLi4uYXJncyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5jbGVhckxvZ3MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdCA9IERFRkFVTFRfRk9STUFULFxuICAgICAgICBmaWx0ZXJTcGVjcyA9IFtdLFxuICAgICAgfSA9IG9wdHM7XG4gICAgICBjb25zdCBjbWQgPSBbXG4gICAgICAgIC4uLnRoaXMuYWRiLmRlZmF1bHRBcmdzLFxuICAgICAgICAnbG9nY2F0JyxcbiAgICAgICAgJy12JywgcmVxdWlyZUZvcm1hdChmb3JtYXQpLFxuICAgICAgICAuLi5mb3JtYXRGaWx0ZXJTcGVjcyhmaWx0ZXJTcGVjcyksXG4gICAgICBdO1xuICAgICAgbG9nLmRlYnVnKGBTdGFydGluZyBsb2dzIGNhcHR1cmUgd2l0aCBjb21tYW5kOiAke3V0aWwucXVvdGUoW3RoaXMuYWRiLnBhdGgsIC4uLmNtZF0pfWApO1xuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3ModGhpcy5hZGIucGF0aCwgY21kKTtcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGBMb2djYXQgdGVybWluYXRlZCB3aXRoIGNvZGUgJHtjb2RlfSwgc2lnbmFsICR7c2lnbmFsfWApO1xuICAgICAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgICAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgICBsb2cud2FybignTG9nY2F0IG5vdCBzdGFydGVkLiBDb250aW51aW5nJyk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvYy5vbignbGluZXMtc3RkZXJyJywgKGxpbmVzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICBpZiAoL2V4ZWN2cFxcKFxcKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdMb2djYXQgcHJvY2VzcyBmYWlsZWQgdG8gc3RhcnQnKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYExvZ2NhdCBwcm9jZXNzIGZhaWxlZCB0byBzdGFydC4gc3RkZXJyOiAke2xpbmV9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm91dHB1dEhhbmRsZXIoXy50cmltKGxpbmUpLCAnU1RERVJSOiAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvYy5vbignbGluZXMtc3Rkb3V0JywgKGxpbmVzKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIHRoaXMub3V0cHV0SGFuZGxlcihfLnRyaW0obGluZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydCgwKTtcbiAgICAgIC8vIHJlc29sdmUgYWZ0ZXIgYSB0aW1lb3V0LCBldmVuIGlmIG5vIG91dHB1dCB3YXMgcmVjb3JkZWRcbiAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgTE9HQ0FUX1BST0NfU1RBUlRVUF9USU1FT1VUKTtcbiAgICB9KTtcbiAgfVxuXG4gIG91dHB1dEhhbmRsZXIgKG91dHB1dCwgcHJlZml4ID0gJycpIHtcbiAgICBpZiAoIW91dHB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID49IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgdGhpcy5sb2dzLnNoaWZ0KCk7XG4gICAgICBpZiAodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID4gMCkge1xuICAgICAgICAtLXRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0T2JqID0ge1xuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgbGV2ZWw6ICdBTEwnLFxuICAgICAgbWVzc2FnZTogb3V0cHV0LFxuICAgIH07XG4gICAgdGhpcy5sb2dzLnB1c2gob3V0cHV0T2JqKTtcbiAgICB0aGlzLmVtaXQoJ291dHB1dCcsIG91dHB1dE9iaik7XG4gICAgY29uc3QgaXNUcmFjZSA9IC9XXFwvVHJhY2UvLnRlc3Qob3V0cHV0KTtcbiAgICBpZiAodGhpcy5kZWJ1ZyAmJiAoIWlzVHJhY2UgfHwgdGhpcy5kZWJ1Z1RyYWNlKSkge1xuICAgICAgbG9nLmRlYnVnKHByZWZpeCArIG91dHB1dCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RvcENhcHR1cmUgKCkge1xuICAgIGxvZy5kZWJ1ZygnU3RvcHBpbmcgbG9nY2F0IGNhcHR1cmUnKTtcbiAgICBpZiAoIXRoaXMucHJvYyB8fCAhdGhpcy5wcm9jLmlzUnVubmluZykge1xuICAgICAgbG9nLmRlYnVnKCdMb2djYXQgYWxyZWFkeSBzdG9wcGVkJyk7XG4gICAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2MucmVtb3ZlQWxsTGlzdGVuZXJzKCdleGl0Jyk7XG4gICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgZ2V0TG9ncyAoKSB7XG4gICAgaWYgKHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA8IHRoaXMubG9ncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubG9ncy5zbGljZSh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QpO1xuICAgICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gdGhpcy5sb2dzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGdldEFsbExvZ3MgKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ3M7XG4gIH1cblxuICBhc3luYyBjbGVhciAoKSB7XG4gICAgbG9nLmRlYnVnKCdDbGVhcmluZyBsb2djYXQgbG9ncyBmcm9tIGRldmljZScpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhcmdzID0gWy4uLnRoaXMuYWRiLmRlZmF1bHRBcmdzLCAnbG9nY2F0JywgJy1jJ107XG4gICAgICBhd2FpdCBleGVjKHRoaXMuYWRiLnBhdGgsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYEZhaWxlZCB0byBjbGVhciBsb2djYXQgbG9nczogJHtlcnIuc3RkZXJyIHx8IGVyci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2djYXQ7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBREEsTUFBTTtFQUFFQTtBQUFGLElBQW1CQyxlQUF6Qjs7QUFHQSxNQUFNQyxHQUFHLEdBQUdDLGVBQUEsQ0FBT0MsU0FBUCxDQUFpQixRQUFqQixDQUFaOztBQUNBLE1BQU1DLGVBQWUsR0FBRyxLQUF4QjtBQUNBLE1BQU1DLDJCQUEyQixHQUFHLEtBQXBDO0FBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQixLQUFyQixFQUE0QixRQUE1QixFQUFzQyxLQUF0QyxFQUE2QyxNQUE3QyxFQUFxRCxZQUFyRCxFQUFtRSxNQUFuRSxDQUExQjtBQUNBLE1BQU1DLG9CQUFvQixHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdB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